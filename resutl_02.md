D:\Python\python-3.11.8\python.exe D:\毕业论文\code\pyhydroqc-lasted\Examples\SingleSite_Detect.py 
2024-03-22 17:14:59.461433: I tensorflow/core/util/port.cc:113] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.
WARNING:tensorflow:From D:\Python\python-3.11.8\Lib\site-packages\keras\src\losses.py:2976: The name tf.losses.sparse_softmax_cross_entropy is deprecated. Please use tf.compat.v1.losses.sparse_softmax_cross_entropy instead.

Rules based detection complete.


Processing ARIMA detections.
temp ARIMA model complete.
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  predictions.predicted_mean[0] = data[0]
Threshold determination complete.
ratio of detections: 0.002856 %

Processing ARIMA detections.
cond ARIMA model complete.
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  predictions.predicted_mean[0] = data[0]
Threshold determination complete.
ratio of detections: 0.174191 %

Processing ARIMA detections.
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  predictions.predicted_mean[0] = data[0]
ph ARIMA model complete.
Threshold determination complete.
ratio of detections: 0.025700 %

Processing ARIMA detections.
do ARIMA model complete.
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:75: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  residuals[0][0] = 0
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  predictions.predicted_mean[0] = data[0]
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\modeling_utilities.py:76: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  predictions.predicted_mean[0] = data[0]
Threshold determination complete.
ratio of detections: 0.008567 %
ARIMA detection complete.


Processing LSTM univariate ModelType.VANILLA detections.
WARNING:tensorflow:From D:\Python\python-3.11.8\Lib\site-packages\keras\src\backend.py:873: The name tf.get_default_graph is deprecated. Please use tf.compat.v1.get_default_graph instead.

2024-03-22 17:16:00.693640: I tensorflow/core/platform/cpu_feature_guard.cc:182] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.
To enable the following instructions: SSE SSE2 SSE3 SSE4.1 SSE4.2 AVX2 AVX_VNNI FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.
WARNING:tensorflow:From D:\Python\python-3.11.8\Lib\site-packages\keras\src\optimizers\__init__.py:309: The name tf.train.Optimizer is deprecated. Please use tf.compat.v1.train.Optimizer instead.

WARNING:tensorflow:From D:\Python\python-3.11.8\Lib\site-packages\keras\src\utils\tf_utils.py:492: The name tf.ragged.RaggedTensorValue is deprecated. Please use tf.compat.v1.ragged.RaggedTensorValue instead.

625/625 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step - loss: 0.0271
temp ModelType.VANILLA LSTM model complete.
Threshold determination complete.
ratio of detections: 0.028560 %

Processing LSTM univariate ModelType.VANILLA detections.
625/625 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step - loss: 0.1060
cond ModelType.VANILLA LSTM model complete.
Threshold determination complete.
ratio of detections: 0.139944 %

Processing LSTM univariate ModelType.VANILLA detections.
625/625 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step - loss: 0.1683
ph ModelType.VANILLA LSTM model complete.
Threshold determination complete.
ratio of detections: 0.002856 %

Processing LSTM univariate ModelType.VANILLA detections.
625/625 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step - loss: 0.1902
do ModelType.VANILLA LSTM model complete.
Threshold determination complete.
ratio of detections: 0.000000 %

Processing LSTM univariate ModelType.BIDIRECTIONAL detections.
625/625 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 3s 2ms/step
1095/1095 [==============================] - 2s 2ms/step - loss: 0.0275
temp ModelType.BIDIRECTIONAL LSTM model complete.
Threshold determination complete.
ratio of detections: 0.028564 %

Processing LSTM univariate ModelType.BIDIRECTIONAL detections.
625/625 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 3s 2ms/step
1095/1095 [==============================] - 2s 2ms/step - loss: 0.0649
cond ModelType.BIDIRECTIONAL LSTM model complete.
Threshold determination complete.
ratio of detections: 0.145677 %

Processing LSTM univariate ModelType.BIDIRECTIONAL detections.
625/625 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 3s 2ms/step
1095/1095 [==============================] - 2s 2ms/step - loss: 0.1582
ph ModelType.BIDIRECTIONAL LSTM model complete.
Threshold determination complete.
ratio of detections: 0.005713 %

Processing LSTM univariate ModelType.BIDIRECTIONAL detections.
625/625 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 2s 2ms/step - loss: 0.1536
do ModelType.BIDIRECTIONAL LSTM model complete.
Threshold determination complete.
ratio of detections: 0.005713 %

Processing LSTM multivariate ModelType.VANILLA detections.
Raw data shape: (35019, 4)
Observed data shape: (35019, 4)
Initial anomalies data shape: (35019, 4)
625/625 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step
1095/1095 [==============================] - 1s 1ms/step - loss: 0.1829
multivariate ModelType.VANILLA LSTM model complete.

ratio of detections: 0.028560 %
ratio of detections: 0.148512 %
ratio of detections: 0.008568 %
ratio of detections: 0.002856 %
Threshold determination complete.

Processing LSTM multivariate ModelType.BIDIRECTIONAL detections.
Raw data shape: (35019, 4)
Observed data shape: (35019, 4)
Initial anomalies data shape: (35019, 4)
625/625 [==============================] - 2s 2ms/step
1095/1095 [==============================] - 3s 2ms/step
1095/1095 [==============================] - 2s 2ms/step - loss: 0.1275
multivariate ModelType.BIDIRECTIONAL LSTM model complete.

ratio of detections: 0.028564 %
ratio of detections: 0.125682 %
ratio of detections: 0.005713 %
ratio of detections: 0.005713 %
Threshold determination complete.
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:157: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '0' has dtype incompatible with bool, please explicitly cast to a compatible dtype first.
  df.loc[df['arima_group'] == i, 'ARIMA_event'] = 0
D:\Python\python-3.11.8\Lib\site-packages\pmdarima\arima\auto.py:444: UserWarning: Input time-series is completely constant; returning a (0, 0, 0) ARMA.
  warnings.warn('Input time-series is completely constant; '
tempcorrection complete
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:177: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '0' has dtype incompatible with bool, please explicitly cast to a compatible dtype first.
  df.loc[df['arima_group'] == i, 'ARIMA_event'] = 0
condcorrection complete
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:177: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '0' has dtype incompatible with bool, please explicitly cast to a compatible dtype first.
  df.loc[df['arima_group'] == i, 'ARIMA_event'] = 0
phcorrection complete
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:35: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if ((df.loc[df[group] == i][anomalies][0] == 0) and (group_len < min_group_len)):
D:\毕业论文\code\pyhydroqc-lasted\pyhydroqc\arima_correct.py:177: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '0' has dtype incompatible with bool, please explicitly cast to a compatible dtype first.
  df.loc[df['arima_group'] == i, 'ARIMA_event'] = 0
docorrection complete
Traceback (most recent call last):
  File "D:\毕业论文\code\pyhydroqc-lasted\Examples\SingleSite_Detect.py", line 289, in <module>
    corrections[snsr].to_csv(r'Examples/' + site + '_' + snsr + '_corrections.csv')
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\util\_decorators.py", line 333, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\core\generic.py", line 3964, in to_csv
    return DataFrameRenderer(formatter).to_csv(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\io\formats\format.py", line 1014, in to_csv
    csv_formatter.save()
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\io\formats\csvs.py", line 251, in save
    with get_handle(
         ^^^^^^^^^^^
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\io\common.py", line 749, in get_handle
    check_parent_directory(str(handle))
  File "D:\Python\python-3.11.8\Lib\site-packages\pandas\io\common.py", line 616, in check_parent_directory
    raise OSError(rf"Cannot save file into a non-existent directory: '{parent}'")
OSError: Cannot save file into a non-existent directory: 'Examples'

Process finished with exit code 1
